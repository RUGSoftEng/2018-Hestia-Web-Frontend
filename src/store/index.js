// src/store/index.js

import Vue from 'vue';
import Vuex from 'vuex';

// imports of AJAX functions
import {
  httpGetServers,
  httpPostServerRequest,
  httpGetServer,
  httpPostServers,
  httpDeleteServer,
  httpPutServer,
  httpPostServerPing,
  httpGetServerPresets,
  httpDeleteServerPreset,
  httpPostServerPresets,
  httpPostServerBatchRequest,
} from '@/api/dispatch';
import {
  preparePayloadPostServer,
  preparePayloadPutServer,
  preparePayloadGetServerDevice,
  perparePayloadDeleteServerDevice,
  preparePayloadPutServerDevice,
  preparePayloadPostServerDevice,
  preparePayloadGetServerPlugins,
  preparePayloadGetServerPluginsCollections,
  preparePayloadGetServerPluginsCollectionDevice,
  preparePayloadPostServerDevicesActivator,
  preparePayloadPostServerPreset,
  preparePayloadPostServerBatchRequest,
} from '@/api/beforeDispatch';
import {
  insertServerPresets,
} from '@/api/afterDispatch';

Vue.use(Vuex);

/**
 * state -  All data objects and arrays the store holds.
 * @type {Object}
 */
const state = {
  serversList: [],
  currentServer: {},
  currentServerDevices: {},
  currentServerPlugins: [],
  currentServerPluginsCollections: [],
  currentPluginAtributes: {},
};

/**
 * actions -  Asynchronous operations
 * The functions are invoked by input events on the website.
 * All functions interect with the backend via http GET, POST, PUT and DELETE.
 * After a succesfull interaction with the backend. The response data is parsed
 * into the store by the mutations defined in this file.
 * @type {Object}
 */
const actions = {

  /**
   * Dispatches a function that loads all the servers linked to your account.
   * On succesfull response the servers inforamtion is loaded into the store.
   * @param  {[type]} context [description]
   * @return {JSON}         [description]
   */
  loadServersList(context) {
    return httpGetServers()
      .then((response) => {
        context.commit('setServersList', { serversList: response.data });
      })
      .catch((error) => {
        // eslint-disable-next-line
        alert(error)
      });
  },
  /**
   * Dispatches the httpPostServers and refreshes the servers list
   * after succesfully adding the server to your account.
   * @param {[type]} context       [description]
   * @param {[type]} serverID      [description]
   * @param {[type]} userID        [description]
   * @param {[type]} serverName    [description]
   * @param {[type]} serverAddress [description]
   * @param {[type]} serverPort    [description]
   */
  addServer(context, { serverID, userID, serverName, serverAddress, serverPort }) {
    const payload = preparePayloadPostServer(
      serverID,
      userID,
      serverName,
      serverAddress,
      serverPort);
    return httpPostServers(payload)
      .then(setTimeout(() => {
        context.dispatch('loadServersList');
      }, 1000,
      ),
      )
      .catch((error) => {
        // eslint-disable-next-line
          alert(error)
      });
  },
  /**
   * Dispatches the httpDeleteServer function to remove the server
   * from your account.
   * @param  {[type]} context  [description]
   * @param  {[type]} serverID [description]
   * @return {[type]}          [description]
   */
  deleteServer(context, { serverID }) {
    return httpDeleteServer(serverID)
      .then(setTimeout(
        context.dispatch('loadServersList'), 1000,
      ),
      )
      .catch((error) => {
        // eslint-disable-next-line
          alert(error)
      });
  },
  /**
   * Dispatches the httpPutServer function with the payload generated by
   * the preparePayloadPutServer function.
   * @param  {[type]} context       [description]
   * @param  {[type]} serverID      [description]
   * @param  {[type]} serverName    [description]
   * @param  {[type]} serverPort    [description]
   * @param  {[type]} serverAddress [description]
   * @return {[type]}               [description]
   */
  putServer(context, { serverID, serverName, serverPort, serverAddress }) {
    const payload = preparePayloadPutServer(serverName, serverAddress, serverPort);
    return httpPutServer(serverID, payload)
      .then(() => {
        setTimeout(
          context.dispatch('loadServersList'), 1000,
        );
      })
      .catch((error) => {
      // eslint-disable-next-line
      alert(error);
      });
  },
  getServer(context, { serverID }) {
    return httpGetServer(serverID)
      .then((response) => {
        context.commit('setServer', { server: response.data });
      })
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
  /**
   * Dispatches the httpPostServerRequest function with the payload generated
   * by the preparePayloadGetServerDevice function.
   * @param  {[type]} context  [description]
   * @param  {[type]} serverID [description]
   * @return {[type]}          [description]
   */
  getServerDevices(context, { serverID }) {
    const payload = preparePayloadGetServerDevice();
    return httpPostServerRequest(serverID, payload)
      .then(response => context.commit('setServerDevices', { server: response }))
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
  deleteServerDevice(context, { serverID, deviceId }) {
    const payload = perparePayloadDeleteServerDevice(deviceId);
    return httpPostServerRequest(serverID, payload)
      .catch((error) => {
      // eslint-disable-next-line
      alert(error);
      });
  },
  putServerDevice(context, { serverID, deviceID, deviceName }) {
    const payload = preparePayloadPutServerDevice(deviceID, deviceName);
    return httpPostServerRequest(serverID, payload)
      .catch((error) => {
      // eslint-disable-next-line
      alert(error);
      });
  },
  postServerDevice(context, { serverID, deviceInfo }) {
    const payload = preparePayloadPostServerDevice(deviceInfo);
    return httpPostServerRequest(serverID, payload)
      .catch((error) => {
      // eslint-disable-next-line
      alert(error);
      });
  },
  getServerPlugins(context, { serverID }) {
    const payload = preparePayloadGetServerPlugins();
    return httpPostServerRequest(serverID, payload)
      .then(response => context.commit('setServerPlugins', { plugins: response }))
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
  getServerPluginsCollections(context, { serverID, collection }) {
    const payload = preparePayloadGetServerPluginsCollections(collection);
    return httpPostServerRequest(serverID, payload)
      .then(response => context.commit('setServerPluginsCollections', { collections: response, collection }))
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
  getServerPluginCollectionDevice(context, { serverID, collection, device }) {
    const payload = preparePayloadGetServerPluginsCollectionDevice(collection, device);
    return httpPostServerRequest(serverID, payload)
      .then(response => context.commit('setServerPluginCollectionDevice', {
        atributes: response,
      }))
      .catch((error) => {
        // eslint-disable-next-line
        console.log(error);
      });
  },
  /**
   * Dispatches httpPostServerRequest with the payload generated by
   * preparePayloadPostServerDevicesActivator. On succes the device state
   * is changed on the server.
   * @param  {[type]} context   [description]
   * @param  {[type]} activator [description]
   * @param  {[type]} deviceID  [description]
   * @param  {[type]} serverID  [description]
   * @return {[type]}           [description]
   */
  activatorUpdate(context, { activator, deviceID, serverID }) {
    const payload = preparePayloadPostServerDevicesActivator(activator, deviceID);
    const test = `${serverID}`;
    return httpPostServerRequest(serverID, payload)
      .then(() => {
        context.dispatch('getServerDevices', { serverID: test });
      })
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
  getServerPresets(context, { serverID }) {
    return httpGetServerPresets(serverID)
      .then((response) => {
        context.commit('setServerPresets', { presets: response.data });
      })
      .catch((error) => {
      // eslint-disable-next-line
      alert(error + "Presets could not be retrieved.");
      });
  },
  postServerPreset(context, { serverID, presetName }) {
    const payload = preparePayloadPostServerPreset(presetName);
    return httpPostServerPresets(serverID, payload)
      .then(() => {
        context.dispatch('getServerPresets', { serverID });
      })
      .catch((error) => {
        // eslint-disable-next-line
        alert(error + "Preset could not be added to the server.");
      });
  },
  deleteServerPreset(context, { serverID, presetID }) {
    context.commit('removeServerPreset', { presetID });
    return httpDeleteServerPreset(serverID, presetID)
      .catch((error) => {
      // eslint-disable-next-line
      alert(error + "Preset could not be removed.");
      });
  },
  initializeServerInformation(context, { serverID }) {
    let server;
    return httpGetServer(serverID)
      .then((response) => {
        server = response.data;
        httpGetServerPresets(serverID)
          .then((response2) => {
            server.presets = response2.data;
            context.commit('setServer', { server });
          });
      });
  },
  postServerBatchRequest(context, { serverID, presetID }) {
    const payload = preparePayloadPostServerBatchRequest(presetID);
    return httpPostServerBatchRequest(serverID, payload)
      .catch((error) => {
        // eslint-disable-next-line
        alert(error);
      });
  },
};
/**
 * mutations -  All function modifying the data in the store.
 * @type {Object}
 */
const mutations = {
  // eslint-disable-next-line
  setServersList(state, payload) {
    const servers = payload.serversList;
    let count = 0;
    servers.forEach((server, index) => {
      httpPostServerPing(server.server_id)
        .then((response) => {
          count += 1;
          if (response.data.value) {
            servers[index].online = true;
          } else {
            servers[index].online = false;
          }
          if (count === servers.length) {
            state.serversList = servers;
          }
        })
        .catch(() => {
          count += 1;
          servers[index].online = false;
          if (count === servers.length) {
            state.serversList = servers;
          }
        });
    });
  },
  // eslint-disable-next-line
  setServer(state, payload) {
    state.currentServer = payload.server;
  },
  // eslint-disable-next-line
  setServerDevices(state, payload) {
    state.currentServerDevices = payload.server.data;
  },
  // eslint-disable-next-line
  setServerPlugins(state, payload) {
    const plugins = [];
    let i = 0;
    payload.plugins.data.forEach((element) => {
      plugins.push({
        text: element,
        key: i,
        value: i,
      });
      i += 1;
    });
    state.currentServerPlugins = plugins;
  },
  // eslint-disable-next-line
  setServerPluginsCollections(state, payload) {
    const collections = [];
    let i = 0;
    payload.collections.data.forEach((element) => {
      collections.push({
        text: element,
        key: i,
        value: i,
      });
      i += 1;
    });
    state.currentServerPluginsCollections = collections;
  },
  // eslint-disable-next-line
  setServerPluginCollectionDevice(state, payload) {
    state.currentPluginAtributes = payload.atributes.data;
  },
  // eslint-disable-next-line
  setActivatorState(state, payload) {
    state.currentServerDevices.forEach((device, index1) => {
      if (device.deviceId === payload.deviceId) {
        device.activators.forEach((activator, index2) => {
          if (activator.activatorId === payload.currentActivator.activatorId) {
            state.currentServerDevices[index1].activators[index2].state = payload.activatorState;
          }
        });
      }
    });
  },
  // eslint-disable-next-line
  setServerPresets(state, payload) {
    state.currentServer = insertServerPresets(state.currentServer, payload.presets);
  },
  // eslint-disable-next-line
  removeServerPreset(state, payload) {
    const newPresets = [];
    state.currentServer.presets.forEach((preset) => {
      if (preset.preset_id !== payload.presetID) {
        newPresets.push(preset);
      }
    });
    state.currentServer.presets = newPresets;
  },
};

const getters = {
  // reusable data accessors
};

const store = new Vuex.Store({
  state,
  actions,
  mutations,
  getters,
});

export default store;
